name: Release Publish

on:
  push:
    tags:
      - "v*"

permissions:
  contents: read

jobs:
  version-policy:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            8.0.x
            10.0.102

      - name: Gate 1 - Validate release tag and derive version
        id: tag
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          REGEX='^v([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$'

          if [[ ! "${TAG}" =~ ${REGEX} ]]; then
            echo "Invalid tag format '${TAG}'. Expected vMAJOR.MINOR.PATCH[-prerelease]." >&2
            exit 1
          fi

          MAJOR="${BASH_REMATCH[1]}"
          MINOR="${BASH_REMATCH[2]}"
          PATCH="${BASH_REMATCH[3]}"
          VERSION="${TAG#v}"
          ASSEMBLY_VERSION="${MAJOR}.${MINOR}.0.0"
          FILE_VERSION="${MAJOR}.${MINOR}.${PATCH}.0"
          echo "version=${VERSION}" >> "${GITHUB_OUTPUT}"
          echo "tag=${TAG}" >> "${GITHUB_OUTPUT}"
          echo "assembly_version=${ASSEMBLY_VERSION}" >> "${GITHUB_OUTPUT}"
          echo "file_version=${FILE_VERSION}" >> "${GITHUB_OUTPUT}"

      - name: Restore (locked mode)
        run: dotnet restore --locked-mode FileClassifier.sln -v minimal

      - name: Build
        run: dotnet build FileClassifier.sln -c Release --no-restore -warnaserror -v minimal

      - name: Source-based tests
        run: dotnet test tests/FileTypeDetectionLib.Tests/FileTypeDetectionLib.Tests.csproj -c Release --no-build -v minimal

      - name: API contract tests
        run: dotnet test tests/FileTypeDetectionLib.Tests/FileTypeDetectionLib.Tests.csproj -c Release --no-build --filter "Category=ApiContract" -v minimal

      - name: Pack with tag version (SSOT)
        run: |
          set -euo pipefail
          mkdir -p artifacts/nuget
          dotnet pack src/FileTypeDetection/FileTypeDetectionLib.vbproj \
            -c Release \
            --no-build \
            -o artifacts/nuget \
            -p:PackageVersion="${{ steps.tag.outputs.version }}" \
            -p:Version="${{ steps.tag.outputs.version }}" \
            -p:AssemblyVersion="${{ steps.tag.outputs.assembly_version }}" \
            -p:FileVersion="${{ steps.tag.outputs.file_version }}"

      - name: Resolve nupkg path
        id: nupkg
        shell: bash
        run: |
          set -euo pipefail
          NUPKG_PATH="$(find artifacts/nuget -maxdepth 1 -type f -name '*.nupkg' ! -name '*.snupkg' | head -n1)"
          if [[ -z "${NUPKG_PATH}" ]]; then
            echo "No .nupkg generated in artifacts/nuget" >&2
            exit 1
          fi
          echo "path=${NUPKG_PATH}" >> "${GITHUB_OUTPUT}"

      - name: Gate 2 - Verify TagVersion == PackageVersion
        shell: bash
        run: |
          set -euo pipefail
          MODE=release \
          TAG="${{ steps.tag.outputs.tag }}" \
          NUPKG_PATH="${{ steps.nupkg.outputs.path }}" \
          bash tools/versioning/check-version-policy.sh

      - name: Consumer smoke against packed package
        run: |
          set -euo pipefail
          dotnet restore samples/PortableConsumer/PortableConsumer.csproj \
            --source artifacts/nuget \
            --source https://api.nuget.org/v3/index.json \
            -p:PortableConsumerPackageVersion="${{ steps.tag.outputs.version }}" \
            -v minimal
          dotnet build samples/PortableConsumer/PortableConsumer.csproj \
            -c Release \
            --no-restore \
            -p:PortableConsumerPackageVersion="${{ steps.tag.outputs.version }}" \
            -v minimal
          dotnet run --project samples/PortableConsumer/PortableConsumer.csproj \
            -c Release \
            -f net10.0 \
            --no-build \
            -p:PortableConsumerPackageVersion="${{ steps.tag.outputs.version }}"

      - name: Package-backed tests against packed package
        run: |
          set -euo pipefail
          dotnet restore tests/PackageBacked.Tests/PackageBacked.Tests.csproj \
            --source artifacts/nuget \
            --source https://api.nuget.org/v3/index.json \
            -p:PackageBackedVersion="${{ steps.tag.outputs.version }}" \
            -v minimal
          dotnet test tests/PackageBacked.Tests/PackageBacked.Tests.csproj \
            -c Release \
            --no-restore \
            -p:PackageBackedVersion="${{ steps.tag.outputs.version }}" \
            -v minimal

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: nuget-package
          path: artifacts/nuget/
          if-no-files-found: error

  publish-nuget:
    runs-on: ubuntu-latest
    needs: version-policy
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - name: Download package artifact
        uses: actions/download-artifact@v4
        with:
          name: nuget-package
          path: artifacts/nuget/

      - name: Resolve nupkg path
        id: nupkg
        shell: bash
        run: |
          set -euo pipefail
          NUPKG_PATH="$(find artifacts/nuget -maxdepth 1 -type f -name '*.nupkg' ! -name '*.snupkg' | head -n1)"
          if [[ -z "${NUPKG_PATH}" ]]; then
            echo "No .nupkg available after artifact download." >&2
            exit 1
          fi
          echo "path=${NUPKG_PATH}" >> "${GITHUB_OUTPUT}"

      - name: Publish to NuGet
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          set -euo pipefail
          if [[ -z "${NUGET_API_KEY}" || "${NUGET_API_KEY}" == "__REPLACE_WITH_NUGET_API_KEY__" ]]; then
            echo "NUGET_API_KEY is missing or still placeholder value." >&2
            exit 1
          fi
          dotnet nuget push "${{ steps.nupkg.outputs.path }}" \
            --api-key "${NUGET_API_KEY}" \
            --source "https://api.nuget.org/v3/index.json" \
            --skip-duplicate
